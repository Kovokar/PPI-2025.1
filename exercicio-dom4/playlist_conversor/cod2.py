import os
from typing import List, Optional, Tuple
from dataclasses import dataclass
from collections import Counter
from dotenv import load_dotenv
import spotipy
from spotipy.oauth2 import SpotifyOAuth


@dataclass
class Track:
    """Representa uma m√∫sica com suas informa√ß√µes b√°sicas."""
    id: str
    name: str
    artist: str
    spotify_url: str


class SpotifyPlaylistManager:
    """Gerenciador para cria√ß√£o e manipula√ß√£o de playlists no Spotify."""
    
    def __init__(self):
        """Inicializa o gerenciador carregando configura√ß√µes do .env"""
        load_dotenv()
        self.sp = None
        self._setup_spotify_client()
    
    def _setup_spotify_client(self) -> None:
        """Configura e autentica o cliente Spotify."""
        scope = "playlist-modify-public playlist-modify-private"
        
        sp_oauth = SpotifyOAuth(
            client_id=os.getenv("SPOTIPY_CLIENT_ID"),
            client_secret=os.getenv("SPOTIPY_CLIENT_SECRET"),
            redirect_uri=os.getenv("SPOTIPY_REDIRECT_URI"),
            scope=scope,
            cache_path=".cache"
        )
        
        # Obt√©m autoriza√ß√£o do usu√°rio
        auth_url = sp_oauth.get_authorize_url()
        print("üîó Por favor, abra esta URL no navegador para autorizar o aplicativo:")
        print(auth_url)
        
        redirected_response = input("\nüìã Cole a URL para onde voc√™ foi redirecionado:\n")
        
        # Processa o token de acesso
        code = sp_oauth.parse_response_code(redirected_response)
        token_info = sp_oauth.get_access_token(code)
        
        self.sp = spotipy.Spotify(auth=token_info['access_token'])
        print("‚úÖ Autentica√ß√£o realizada com sucesso!")
    
    def create_playlist(self, name: str, description: str = "", is_public: bool = True) -> str:
        """
        Cria uma nova playlist na conta do usu√°rio.
        
        Args:
            name: Nome da playlist
            description: Descri√ß√£o da playlist
            is_public: Se a playlist deve ser p√∫blica
            
        Returns:
            ID da playlist criada
        """
        user_id = self.sp.me()['id']
        playlist = self.sp.user_playlist_create(
            user=user_id, 
            name=name, 
            public=is_public, 
            description=description
        )
        
        print(f"\n‚úÖ Playlist '{name}' criada com sucesso!")
        print(f"üîó Link: {playlist['external_urls']['spotify']}")
        
        return playlist['id']
    
    def search_track(self, track_name: str, limit: int = 1, verbose: bool = False) -> Optional[Track]:
        """
        Busca uma m√∫sica pelo nome.
        
        Args:
            track_name: Nome da m√∫sica a ser buscada
            limit: N√∫mero m√°ximo de resultados
            verbose: Se deve imprimir mensagens de erro
            
        Returns:
            Objeto Track se encontrado, None caso contr√°rio
        """
        try:
            results = self.sp.search(q=track_name, type='track', limit=limit)
            tracks = results['tracks']['items']
            
            if not tracks:
                if verbose:
                    print(f"‚ùå M√∫sica '{track_name}' n√£o encontrada")
                return None
            
            track_data = tracks[0]
            return Track(
                id=track_data['id'],
                name=track_data['name'],
                artist=track_data['artists'][0]['name'],
                spotify_url=track_data['external_urls']['spotify']
            )
            
        except Exception as e:
            if verbose:
                print(f"‚ùå Erro ao buscar '{track_name}': {e}")
            return None
    
    def add_tracks_to_playlist(self, playlist_id: str, track_ids: List[str]) -> bool:
        """
        Adiciona m√∫ltiplas m√∫sicas a uma playlist.
        
        Args:
            playlist_id: ID da playlist
            track_ids: Lista de IDs das m√∫sicas
            
        Returns:
            True se todas as m√∫sicas foram adicionadas com sucesso
        """
        try:
            # Spotify API permite at√© 100 tracks por request
            batch_size = 100
            
            for i in range(0, len(track_ids), batch_size):
                batch = track_ids[i:i + batch_size]
                self.sp.playlist_add_items(playlist_id, batch)
            
            print(f"üéµ {len(track_ids)} m√∫sica(s) adicionada(s) √† playlist!")
            return True
            
        except Exception as e:
            print(f"‚ùå Erro ao adicionar m√∫sicas √† playlist: {e}")
            return False
    
    def find_most_common_artist(self, tracks: List[Track]) -> str:
        """
        Encontra o artista mais comum em uma lista de tracks.
        
        Args:
            tracks: Lista de objetos Track
            
        Returns:
            Nome do artista mais comum
        """
        if not tracks:
            return ""
        
        artists = [track.artist for track in tracks]
        counter = Counter(artists)
        most_common_artist, _ = counter.most_common(1)[0]
        
        return most_common_artist
    
    def search_tracks_with_artist_enhancement(self, track_names: List[str]) -> List[Track]:
        """
        Busca m√∫sicas em duas etapas para maior precis√£o:
        1¬™ etapa: Busca inicial para identificar o artista mais comum
        2¬™ etapa: Nova busca de TODAS as m√∫sicas usando "nome_musica + artista_principal"
        
        Args:
            track_names: Lista de nomes das m√∫sicas
            
        Returns:
            Lista de objetos Track encontrados com maior precis√£o
        """
        print("üîç ETAPA 1 - Busca inicial para identificar artista principal...")
        print("-" * 60)
        
        # Primeira etapa: busca inicial para identificar o artista principal
        initial_tracks = []
        artists_found = []
        
        for i, track_name in enumerate(track_names, 1):
            print(f"[{i}/{len(track_names)}] Buscando: {track_name}")
            track = self.search_track(track_name)
            
            if track:
                initial_tracks.append(track)
                artists_found.append(track.artist)
                print(f"    ‚úÖ Encontrado: {track.name} - {track.artist}")
            else:
                print(f"    ‚ùå N√£o encontrado")
        
        if not initial_tracks:
            print("\n‚ùå Nenhuma m√∫sica encontrada na busca inicial")
            return []
        
        # Identifica o artista mais comum
        main_artist = self.find_most_common_artist(initial_tracks)
        artist_count = Counter(artists_found)[main_artist]
        
        print(f"\nüé§ ARTISTA PRINCIPAL IDENTIFICADO: {main_artist}")
        print(f"üìä Apari√ß√µes: {artist_count}/{len(initial_tracks)} m√∫sicas")
        
        # Segunda etapa: busca refinada de TODAS as m√∫sicas com o artista principal
        print(f"\nüîç ETAPA 2 - Busca refinada com '{main_artist}'...")
        print("-" * 60)
        
        refined_tracks = []
        
        for i, track_name in enumerate(track_names, 1):
            enhanced_query = f"{track_name} {main_artist}"
            print(f"[{i}/{len(track_names)}] Buscando: {enhanced_query}")
            
            track = self.search_track(enhanced_query)
            
            if track:
                refined_tracks.append(track)
                print(f"    ‚úÖ Encontrado: {track.name} - {track.artist}")
            else:
                print(f"    ‚ö†Ô∏è  Busca refinada falhou, tentando busca original...")
                # Fallback para busca original se a busca refinada falhar
                fallback_track = self.search_track(track_name)
                if fallback_track:
                    refined_tracks.append(fallback_track)
                    print(f"    ‚úÖ Fallback: {fallback_track.name} - {fallback_track.artist}")
                else:
                    print(f"    ‚ùå M√∫sica n√£o encontrada em nenhuma busca")
        
        print(f"\nüìà RESULTADO FINAL:")
        print(f"   ‚Ä¢ M√∫sicas encontradas na 1¬™ etapa: {len(initial_tracks)}")
        print(f"   ‚Ä¢ M√∫sicas encontradas na 2¬™ etapa: {len(refined_tracks)}")
        print(f"   ‚Ä¢ Melhoria na precis√£o: {len(refined_tracks) - len(initial_tracks):+d}")
        
        return refined_tracks


def main():
    """Fun√ß√£o principal do programa."""
    
    # Lista de m√∫sicas a serem adicionadas
    TRACK_NAMES = [
        "Conde & Dr√°cula - T√° Faltando √îme",
        "Conde & Dr√°cula - Carimb√≥ Do Maraj√≥",
        "Conde & Dr√°cula - De Cabar√© Em Cabar√©",
        "Conde & Dr√°cula - Nem L√°, Nem C√°",
        "Conde & Dr√°cula - Bruxa Feiticeira",
        "Conde & Dr√°cula - O Tropeiro",
        "Conde & Dr√°cula - Caf√© Do Paissandu",
        "Conde & Dr√°cula - Vira Fazendeiro",
        "Conde & Dr√°cula - O Corvo",
        "Conde & Dr√°cula - V√©u De Noiva",
        "Conde & Dr√°cula - A Noite Dos Vampiros",
        "Conde & Dr√°cula - Cavalo De A√ßo"
    ]
    
    try:
        # Inicializa o gerenciador
        manager = SpotifyPlaylistManager()
        
        # Busca as m√∫sicas com melhoria baseada no artista principal
        found_tracks = manager.search_tracks_with_artist_enhancement(TRACK_NAMES)
        
        if not found_tracks:
            print("‚ùå Nenhuma m√∫sica foi encontrada. Encerrando...")
            return
        
        print(f"\nüìä Resumo: {len(found_tracks)} de {len(TRACK_NAMES)} m√∫sicas encontradas")
        
        # Cria a playlist
        playlist_name = "CONDE E DRACULA - Playlist Completa"
        playlist_description = f"Playlist criada automaticamente com {len(found_tracks)} m√∫sicas"
        
        playlist_id = manager.create_playlist(
            name=playlist_name,
            description=playlist_description,
            is_public=True
        )
        
        # Adiciona as m√∫sicas √† playlist
        track_ids = [track.id for track in found_tracks]
        success = manager.add_tracks_to_playlist(playlist_id, track_ids)
        
        if success:
            print(f"\nüéâ Playlist '{playlist_name}' criada com sucesso!")
            print(f"üìã Total de m√∫sicas adicionadas: {len(found_tracks)}")
        else:
            print("\n‚ùå Erro ao adicionar m√∫sicas √† playlist")
            
    except Exception as e:
        print(f"‚ùå Erro geral: {e}")


if __name__ == "__main__":
    main()